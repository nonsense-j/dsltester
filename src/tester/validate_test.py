import os
import xml.etree.ElementTree as ET
from pathlib import Path

from src.utils._kirin import KirinRunner
from src.utils._logger import logger
from src.utils.types import DslValResDict


def validate_tests(dsl_id, val_type: str = "all") -> DslValResDict:
    """
    validate dsl in its corresponding kirin_ws: kirin_ws/{dsl_id}
    Args:
        dsl_id: The DSL ID to validate.
        val_type: Specify the DSL and test dirs to validate ("all", "tmp").
    """
    assert val_type in ["all", "tmp"], f"Invalid test directory name: {val_type}!"
    cur_ws_dir = Path(f"kirin_ws/{dsl_id}") if val_type == "all" else Path(f"kirin_ws/{dsl_id}/tmp")
    if not cur_ws_dir.is_dir():
        logger.error(f"-> Curent workspace directory {cur_ws_dir} does not exist!")
        return dict()

    dsl_dir = cur_ws_dir / "dsl"
    test_dir = cur_ws_dir / "test"
    lib_dir = Path(f"kirin_ws/{dsl_id}") / "lib"
    report_dir = cur_ws_dir / "report"

    logger.info(f"==> Validating checker tests in {cur_ws_dir} in {val_type} mode...")
    # execute kirin dsl (report dir will be automatically created in the test dir)
    if lib_dir.exists():
        KirinRunner.execute_kirin_dsl(dsl_dir, test_dir, report_dir, lib_dir)
    else:
        KirinRunner.execute_kirin_dsl(dsl_dir, test_dir, report_dir)

    return parse_xml_results(dsl_id, val_type)


def sorted_test_files(file_name_list: list[str], type: str = "report") -> list[str]:
    """
    Sort files for report and pass result.
    Used for val_res postprocess to ensure least tests are modified when rearrange_test_info.
    """
    res = []
    if type == "report":
        # AlertingTest1, AlertingTest2, MisAlertingTest, NonAlertingTest1
        res = sorted(file_name_list)
    elif type == "pass":
        # NonAlertingTest1, NonAlertingTest2, MisNonAlertingTest1, AlertingTest1
        res = sorted(file_name_list, key=lambda s: (-(ord(s[0])), s[1:]))
    else:
        raise ValueError(f"--> Invalid test folder type {type}!")
    return res


def parse_xml_results(dsl_id, val_type: str = "all") -> dict[str, DslValResDict]:
    """
    Parse the XML results generated by the DSL validation process.
    Args:
        dsl_id: The DSL ID to parse results for.
        val_type: Specify the DSL and test dirs for validation ("all", "tmp").
    All the files are well sorted as:
    report(keys): AlertingTest1, AlertingTest2, MisAlertingTest, NonAlertingTest1
    pass: NonAlertingTest1, NonAlertingTest2, MisNonAlertingTest1, AlertingTest1
    """
    report_dir = Path(f"kirin_ws/{dsl_id}/report") if val_type == "all" else Path(f"kirin_ws/{dsl_id}/tmp/report")
    if not report_dir.is_dir():
        logger.error(f"-> Report directory {report_dir} does not exist!")
        return dict()

    assert len(list(report_dir.glob("*.xml"))) == 1, f"More than one XML file found in {report_dir}"
    xml_res_file = report_dir / "error_report_1.xml"
    tree = ET.parse(xml_res_file)
    root = tree.getroot()

    # get all the scanned files
    scan_files = set()
    for scan_file in root.findall(".//scanFiles/scanFile"):
        file_name = os.path.basename(scan_file.text)
        scan_files.add(file_name)

    result = {}
    for error in root.findall(".//errors/error"):
        defect_info = error.find("defectInfo")
        checker_name = defect_info.find("checkerName").text
        file_path = defect_info.find("fileName").text
        file_name = os.path.basename(file_path)
        report_line = int(defect_info.find("reportLine").text)

        # new checker name
        if checker_name not in result:
            result[checker_name] = {"report": dict(), "pass": []}

        # add info: {file_name: [report_line, ...]}
        if file_name not in result[checker_name]["report"]:
            result[checker_name]["report"][file_name] = [report_line]
        else:
            result[checker_name]["report"][file_name].append(report_line)

    # postprocess the result
    for checker_name in result:
        # sort the key of report dict
        report_dict_ori = result[checker_name]["report"]
        result[checker_name]["report"] = {
            k: report_dict_ori[k] for k in sorted_test_files(list(report_dict_ori.keys()), type="report")
        }
        # get sorted passed files
        pass_files = [f for f in scan_files if f not in result[checker_name]["report"]]
        result[checker_name]["pass"] = sorted_test_files(pass_files, type="pass")

    # handle unreported DSL_ORI checker
    if "DSL_ORI" not in result:
        if dsl_id in result:
            result["DSL_ORI"] = result[dsl_id]
            del result[dsl_id]
        # For backward compatibility with older version of CodeNavi
        if "SecH_default_rule_name" in result:
            result["DSL_ORI"] = result["SecH_default_rule_name"]
            del result["SecH_default_rule_name"]

    # checkers not reported in the XML file
    checker_dir = Path(f"kirin_ws/{dsl_id}/dsl") if val_type == "all" else Path(f"kirin_ws/{dsl_id}/tmp/dsl")
    # collect all .kirin file in checker_dir and its sub_dir recursively into the checker_list
    for checker_file in checker_dir.glob("**/*.kirin"):
        checker_name = checker_file.stem
        if checker_name not in result:
            result[checker_name] = {"report": dict(), "pass": sorted_test_files(list(scan_files), type="pass")}

    # log output
    sorted_keys = sorted(list(result.keys()), key=lambda x: (len(x), x))
    res_str = ""
    for checker_name in sorted_keys:
        res_str += f"=> Checker: {checker_name}\n"
        res_str += f"\treported: {', '.join(result[checker_name]['report'].keys())}\n"
        res_str += f"\tpassed: {', '.join(result[checker_name]['pass'])}\n\n"
    logger.info(f"==> Validation Result:\n{res_str}")

    return result


if __name__ == "__main__":
    # Example usage
    dsl_id = "ONLINE_Use_Unsafe_Algorithm_IDEA"
    parse_xml_results(dsl_id)
